# =============================================================================
# PRODUCTION ENVIRONMENT CONFIGURATION
# =============================================================================
# Purpose: Configuration values for production environment
# Why needed: Provides environment-specific settings for production
# This file contains all configurable values for the production environment

# =============================================================================
# GLOBAL CONFIGURATION
# =============================================================================
global:
  # Global configuration settings
  environment: production
  # environment: production - Environment identifier
  # Purpose: Identifies this as production environment
  # Impact: Used throughout the application for environment-specific behavior
  # Production consideration: Different values for staging/development
  
  namespace: ecommerce
  # namespace: ecommerce - Kubernetes namespace
  # Purpose: Namespace for production resources
  # Impact: All resources are created in this namespace
  # Production consideration: Use dedicated namespace for production
  
  imageRegistry: "registry.company.com"
  # imageRegistry: registry.company.com - Container image registry
  # Purpose: Base registry for all container images
  # Impact: All images are pulled from this registry
  # Production consideration: Use production registry with proper security
  
  imageTag: "v1.0.0"
  # imageTag: v1.0.0 - Default image tag
  # Purpose: Default tag for all container images
  # Impact: All images use this tag unless overridden
  # Production consideration: Use specific version tags in production

# =============================================================================
# E-COMMERCE APPLICATION CONFIGURATION
# =============================================================================
ecommerce:
  # E-commerce application configuration
  enabled: true
  # enabled: true - Enable e-commerce application
  # Purpose: Controls whether to deploy the e-commerce application
  # Impact: Application is deployed when true
  # Production consideration: Always true in production
  
  # Backend configuration
  backend:
    enabled: true
    # enabled: true - Enable backend service
    # Purpose: Controls whether to deploy the backend
    # Impact: Backend is deployed when true
    # Production consideration: Always true in production
    
    image:
      repository: "ecommerce-backend"
      # repository: ecommerce-backend - Image repository name
      # Purpose: Name of the backend image repository
      # Impact: Backend image is pulled from this repository
      # Production consideration: Use consistent naming across environments
      
      tag: "v1.0.0"
      # tag: v1.0.0 - Image tag
      # Purpose: Specific version of the backend image
      # Impact: Backend uses this specific image version
      # Production consideration: Use specific version tags in production
      
      pullPolicy: "Always"
      # pullPolicy: Always - Image pull policy
      # Purpose: Always pull the latest image
      # Impact: Image is always pulled from registry
      # Production consideration: Use Always in production for latest changes
    
    replicas: 3
    # replicas: 3 - Number of backend replicas
    # Purpose: Controls backend scaling
    # Impact: Three replicas for high availability
    # Production consideration: Use multiple replicas in production for high availability
    
    resources:
      # resources: Resource requirements and limits
      # Purpose: Specifies CPU and memory requirements
      # Impact: Kubernetes schedules pods based on these requirements
      # Production consideration: Adjust based on actual usage patterns
      
      requests:
        # requests: Minimum resource requirements
        # Purpose: Specifies minimum resources needed
        # Impact: Kubernetes ensures these resources are available
        # Production consideration: Should be based on actual usage
        
        cpu: "500m"
        # cpu: 500m - CPU request
        # Purpose: Minimum CPU allocation (0.5 cores)
        # Impact: Backend is guaranteed at least this CPU
        # Production consideration: Adjust based on actual usage
        
        memory: "512Mi"
        # memory: 512Mi - Memory request
        # Purpose: Minimum memory allocation (512 megabytes)
        # Impact: Backend is guaranteed at least this memory
        # Production consideration: Adjust based on actual usage
      
      limits:
        # limits: Maximum resource usage
        # Purpose: Specifies maximum resources the backend can use
        # Impact: Backend cannot exceed these limits
        # Production consideration: Prevents resource exhaustion
        
        cpu: "2000m"
        # cpu: 2000m - CPU limit
        # Purpose: Maximum CPU allocation (2 cores)
        # Impact: Backend cannot use more than this CPU
        # Production consideration: Adjust based on actual usage
        
        memory: "2Gi"
        # memory: 2Gi - Memory limit
        # Purpose: Maximum memory allocation (2 gigabytes)
        # Impact: Backend cannot use more than this memory
        # Production consideration: Adjust based on actual usage
    
    service:
      # service: Backend service configuration
      # Purpose: Configures how the backend is exposed
      # Impact: Determines backend accessibility
      # Production consideration: Use appropriate service types
      
      type: "ClusterIP"
      # type: ClusterIP - Service type
      # Purpose: Exposes service on cluster-internal IP
      # Impact: Backend is only accessible within the cluster
      # Production consideration: Use ClusterIP for security
      
      port: 8000
      # port: 8000 - Service port
      # Purpose: Port on which the service listens
      # Impact: Clients connect to this port to access backend
      # Production consideration: Use standard ports for consistency
    
    env:
      # env: Environment variables for backend
      # Purpose: Provides configuration data to the backend
      # Impact: Backend behavior is controlled by these variables
      # Production consideration: Use different values for different environments
      
      NODE_ENV: "production"
      # NODE_ENV: production - Node.js environment
      # Purpose: Sets the Node.js environment
      # Impact: Backend runs in production mode
      # Production consideration: Use production in production environment
      
      PORT: "8000"
      # PORT: 8000 - Backend port
      # Purpose: Port on which the backend listens
      # Impact: Backend accepts connections on this port
      # Production consideration: Use standard ports for consistency
      
      LOG_LEVEL: "info"
      # LOG_LEVEL: info - Logging level
      # Purpose: Controls the verbosity of logging
      # Impact: Backend logs appropriate information in production
      # Production consideration: Use info or warn in production
    
    # Health checks
    healthCheck:
      # healthCheck: Health check configuration
      # Purpose: Configures health checks for the backend
      # Impact: Determines backend health status
      # Production consideration: Essential for production reliability
      
      enabled: true
      # enabled: true - Enable health checks
      # Purpose: Controls whether to enable health checks
      # Impact: Health checks are enabled when true
      # Production consideration: Always true in production
      
      livenessProbe:
        # livenessProbe: Liveness probe configuration
        # Purpose: Determines if the backend is running properly
        # Impact: Kubernetes restarts backend if probe fails
        # Production consideration: Critical for maintaining service availability
        
        httpGet:
          path: "/health"
          port: 8000
          scheme: "HTTP"
        initialDelaySeconds: 30
        periodSeconds: 10
        timeoutSeconds: 5
        failureThreshold: 3
      
      readinessProbe:
        # readinessProbe: Readiness probe configuration
        # Purpose: Determines if the backend is ready to serve traffic
        # Impact: Kubernetes only sends traffic to ready backends
        # Production consideration: Critical for proper load balancing
        
        httpGet:
          path: "/ready"
          port: 8000
          scheme: "HTTP"
        initialDelaySeconds: 5
        periodSeconds: 5
        timeoutSeconds: 3
        failureThreshold: 3
    
    # Horizontal Pod Autoscaler
    hpa:
      # hpa: Horizontal Pod Autoscaler configuration
      # Purpose: Automatically scales backend based on metrics
      # Impact: Backend scales up/down based on load
      # Production consideration: Essential for handling variable load
      
      enabled: true
      # enabled: true - Enable HPA
      # Purpose: Controls whether to enable HPA
      # Impact: HPA is enabled when true
      # Production consideration: Always true in production
      
      minReplicas: 3
      # minReplicas: 3 - Minimum replicas
      # Purpose: Minimum number of backend replicas
      # Impact: Backend never scales below this number
      # Production consideration: Set based on minimum load requirements
      
      maxReplicas: 10
      # maxReplicas: 10 - Maximum replicas
      # Purpose: Maximum number of backend replicas
      # Impact: Backend never scales above this number
      # Production consideration: Set based on maximum load capacity
      
      targetCPUUtilizationPercentage: 70
      # targetCPUUtilizationPercentage: 70 - Target CPU utilization
      # Purpose: CPU utilization threshold for scaling
      # Impact: Backend scales when CPU exceeds this percentage
      # Production consideration: Adjust based on performance requirements
      
      targetMemoryUtilizationPercentage: 80
      # targetMemoryUtilizationPercentage: 80 - Target memory utilization
      # Purpose: Memory utilization threshold for scaling
      # Impact: Backend scales when memory exceeds this percentage
      # Production consideration: Adjust based on performance requirements
  
  # Frontend configuration
  frontend:
    enabled: true
    # enabled: true - Enable frontend service
    # Purpose: Controls whether to deploy the frontend
    # Impact: Frontend is deployed when true
    # Production consideration: Always true in production
    
    image:
      repository: "ecommerce-frontend"
      # repository: ecommerce-frontend - Image repository name
      # Purpose: Name of the frontend image repository
      # Impact: Frontend image is pulled from this repository
      # Production consideration: Use consistent naming across environments
      
      tag: "v1.0.0"
      # tag: v1.0.0 - Image tag
      # Purpose: Specific version of the frontend image
      # Impact: Frontend uses this specific image version
      # Production consideration: Use specific version tags in production
      
      pullPolicy: "Always"
      # pullPolicy: Always - Image pull policy
      # Purpose: Always pull the latest image
      # Impact: Image is always pulled from registry
      # Production consideration: Use Always in production for latest changes
    
    replicas: 2
    # replicas: 2 - Number of frontend replicas
    # Purpose: Controls frontend scaling
    # Impact: Two replicas for high availability
    # Production consideration: Use multiple replicas in production for high availability
    
    resources:
      # resources: Resource requirements and limits
      # Purpose: Specifies CPU and memory requirements
      # Impact: Kubernetes schedules pods based on these requirements
      # Production consideration: Adjust based on actual usage patterns
      
      requests:
        # requests: Minimum resource requirements
        # Purpose: Specifies minimum resources needed
        # Impact: Kubernetes ensures these resources are available
        # Production consideration: Should be based on actual usage
        
        cpu: "100m"
        # cpu: 100m - CPU request
        # Purpose: Minimum CPU allocation (0.1 cores)
        # Impact: Frontend is guaranteed at least this CPU
        # Production consideration: Adjust based on actual usage
        
        memory: "128Mi"
        # memory: 128Mi - Memory request
        # Purpose: Minimum memory allocation (128 megabytes)
        # Impact: Frontend is guaranteed at least this memory
        # Production consideration: Adjust based on actual usage
      
      limits:
        # limits: Maximum resource usage
        # Purpose: Specifies maximum resources the frontend can use
        # Impact: Frontend cannot exceed these limits
        # Production consideration: Prevents resource exhaustion
        
        cpu: "500m"
        # cpu: 500m - CPU limit
        # Purpose: Maximum CPU allocation (0.5 cores)
        # Impact: Frontend cannot use more than this CPU
        # Production consideration: Adjust based on actual usage
        
        memory: "256Mi"
        # memory: 256Mi - Memory limit
        # Purpose: Maximum memory allocation (256 megabytes)
        # Impact: Frontend cannot use more than this memory
        # Production consideration: Adjust based on actual usage
    
    service:
      # service: Frontend service configuration
      # Purpose: Configures how the frontend is exposed
      # Impact: Determines frontend accessibility
      # Production consideration: Use appropriate service types
      
      type: "ClusterIP"
      # type: ClusterIP - Service type
      # Purpose: Exposes service on cluster-internal IP
      # Impact: Frontend is only accessible within the cluster
      # Production consideration: Use ClusterIP for security
      
      port: 3000
      # port: 3000 - Service port
      # Purpose: Port on which the service listens
      # Impact: Clients connect to this port to access frontend
      # Production consideration: Use standard ports for consistency
    
    env:
      # env: Environment variables for frontend
      # Purpose: Provides configuration data to the frontend
      # Impact: Frontend behavior is controlled by these variables
      # Production consideration: Use different values for different environments
      
      NODE_ENV: "production"
      # NODE_ENV: production - Node.js environment
      # Purpose: Sets the Node.js environment
      # Impact: Frontend runs in production mode
      # Production consideration: Use production in production environment
      
      PORT: "3000"
      # PORT: 3000 - Frontend port
      # Purpose: Port on which the frontend listens
      # Impact: Frontend accepts connections on this port
      # Production consideration: Use standard ports for consistency
      
      REACT_APP_API_BASE_URL: "https://api.ecommerce.company.com"
      # REACT_APP_API_BASE_URL: Backend API URL
      # Purpose: URL for frontend to access backend API
      # Impact: Frontend makes API calls to this URL
      # Production consideration: Use external URLs in production
  
  # Database configuration
  database:
    enabled: true
    # enabled: true - Enable database service
    # Purpose: Controls whether to deploy the database
    # Impact: Database is deployed when true
    # Production consideration: Always true in production
    
    image:
      repository: "postgres"
      # repository: postgres - Image repository name
      # Purpose: Name of the database image repository
      # Impact: Database image is pulled from this repository
      # Production consideration: Use consistent naming across environments
      
      tag: "15-alpine"
      # tag: 15-alpine - Image tag
      # Purpose: Specific version of the database image
      # Impact: Database uses this specific image version
      # Production consideration: Use specific version tags in production
      
      pullPolicy: "IfNotPresent"
      # pullPolicy: IfNotPresent - Image pull policy
      # Purpose: Controls when to pull the image
      # Impact: Image is only pulled if not present locally
      # Production consideration: Use IfNotPresent for stability
    
    replicas: 1
    # replicas: 1 - Number of database replicas
    # Purpose: Controls database scaling
    # Impact: Single replica for data consistency
    # Production consideration: Use single replica for data consistency
    
    resources:
      # resources: Resource requirements and limits
      # Purpose: Specifies CPU and memory requirements
      # Impact: Kubernetes schedules pods based on these requirements
      # Production consideration: Adjust based on actual usage patterns
      
      requests:
        # requests: Minimum resource requirements
        # Purpose: Specifies minimum resources needed
        # Impact: Kubernetes ensures these resources are available
        # Production consideration: Should be based on actual usage
        
        cpu: "500m"
        # cpu: 500m - CPU request
        # Purpose: Minimum CPU allocation (0.5 cores)
        # Impact: Database is guaranteed at least this CPU
        # Production consideration: Adjust based on actual usage
        
        memory: "1Gi"
        # memory: 1Gi - Memory request
        # Purpose: Minimum memory allocation (1 gigabyte)
        # Impact: Database is guaranteed at least this memory
        # Production consideration: Adjust based on actual usage
      
      limits:
        # limits: Maximum resource usage
        # Purpose: Specifies maximum resources the database can use
        # Impact: Database cannot exceed these limits
        # Production consideration: Prevents resource exhaustion
        
        cpu: "2000m"
        # cpu: 2000m - CPU limit
        # Purpose: Maximum CPU allocation (2 cores)
        # Impact: Database cannot use more than this CPU
        # Production consideration: Adjust based on actual usage
        
        memory: "4Gi"
        # memory: 4Gi - Memory limit
        # Purpose: Maximum memory allocation (4 gigabytes)
        # Impact: Database cannot use more than this memory
        # Production consideration: Adjust based on actual usage
    
    service:
      # service: Database service configuration
      # Purpose: Configures how the database is exposed
      # Impact: Determines database accessibility
      # Production consideration: Use appropriate service types
      
      type: "ClusterIP"
      # type: ClusterIP - Service type
      # Purpose: Exposes service on cluster-internal IP
      # Impact: Database is only accessible within the cluster
      # Production consideration: Use ClusterIP for security
      
      port: 5432
      # port: 5432 - Service port
      # Purpose: Port on which the service listens
      # Impact: Clients connect to this port to access database
      # Production consideration: Use standard ports for consistency
    
    env:
      # env: Environment variables for database
      # Purpose: Provides configuration data to the database
      # Impact: Database behavior is controlled by these variables
      # Production consideration: Use different values for different environments
      
      POSTGRES_DB: "ecommerce"
      # POSTGRES_DB: ecommerce - Database name
      # Purpose: Name of the database to create
      # Impact: Database creates this database on startup
      # Production consideration: Use different names for different environments
      
      POSTGRES_USER: "ecommerce_user"
      # POSTGRES_USER: ecommerce_user - Database user
      # Purpose: Username for database access
      # Impact: Database creates this user on startup
      # Production consideration: Use different users for different environments
      
      POSTGRES_PASSWORD: "secure_production_password"
      # POSTGRES_PASSWORD: secure_production_password - Database password
      # Purpose: Password for database access
      # Impact: Database uses this password for authentication
      # Production consideration: Use strong passwords in production
    
    persistence:
      # persistence: Database persistence configuration
      # Purpose: Configures data persistence for the database
      # Impact: Determines how database data is stored
      # Production consideration: Use appropriate storage classes
      
      enabled: true
      # enabled: true - Enable persistence
      # Purpose: Controls whether to use persistent storage
      # Impact: Database data is persisted when true
      # Production consideration: Always true in production
      
      size: "100Gi"
      # size: 100Gi - Storage size
      # Purpose: Size of the persistent volume
      # Impact: Database has this much storage available
      # Production consideration: Adjust based on actual usage
      
      storageClass: "fast-ssd"
      # storageClass: fast-ssd - Storage class
      # Purpose: Kubernetes storage class to use
      # Impact: Determines storage backend and performance
      # Production consideration: Use appropriate storage classes for production
    
    # Database backup
    backup:
      # backup: Database backup configuration
      # Purpose: Configures automated database backups
      # Impact: Determines backup frequency and retention
      # Production consideration: Essential for data protection
      
      enabled: true
      # enabled: true - Enable backup
      # Purpose: Controls whether to enable automated backups
      # Impact: Backups are created when true
      # Production consideration: Always true in production
      
      schedule: "0 2 * * *"
      # schedule: 0 2 * * * - Backup schedule
      # Purpose: Cron expression for backup frequency
      # Impact: Backups are created daily at 2 AM
      # Production consideration: Adjust based on data criticality
      
      retention: "30d"
      # retention: 30d - Backup retention
      # Purpose: How long to keep backups
      # Impact: Backups are kept for 30 days
      # Production consideration: Adjust based on compliance requirements

# =============================================================================
# MONITORING CONFIGURATION
# =============================================================================
monitoring:
  # Monitoring stack configuration
  enabled: true
  # enabled: true - Enable monitoring stack
  # Purpose: Controls whether to deploy the monitoring stack
  # Impact: Monitoring stack is deployed when true
  # Production consideration: Always true in production
  
  # Prometheus configuration
  prometheus:
    enabled: true
    # enabled: true - Enable Prometheus
    # Purpose: Controls whether to deploy Prometheus
    # Impact: Prometheus is deployed when true
    # Production consideration: Always true in production
    
    image:
      repository: "prom/prometheus"
      # repository: prom/prometheus - Image repository name
      # Purpose: Name of the Prometheus image repository
      # Impact: Prometheus image is pulled from this repository
      # Production consideration: Use consistent naming across environments
      
      tag: "v2.45.0"
      # tag: v2.45.0 - Image tag
      # Purpose: Specific version of the Prometheus image
      # Impact: Prometheus uses this specific image version
      # Production consideration: Use specific version tags in production
      
      pullPolicy: "IfNotPresent"
      # pullPolicy: IfNotPresent - Image pull policy
      # Purpose: Controls when to pull the image
      # Impact: Image is only pulled if not present locally
      # Production consideration: Use IfNotPresent for stability
    
    replicas: 1
    # replicas: 1 - Number of Prometheus replicas
    # Purpose: Controls Prometheus scaling
    # Impact: Single replica for data consistency
    # Production consideration: Use single replica for data consistency
    
    resources:
      # resources: Resource requirements and limits
      # Purpose: Specifies CPU and memory requirements
      # Impact: Kubernetes schedules pods based on these requirements
      # Production consideration: Adjust based on actual usage patterns
      
      requests:
        # requests: Minimum resource requirements
        # Purpose: Specifies minimum resources needed
        # Impact: Kubernetes ensures these resources are available
        # Production consideration: Should be based on actual usage
        
        cpu: "500m"
        # cpu: 500m - CPU request
        # Purpose: Minimum CPU allocation (0.5 cores)
        # Impact: Prometheus is guaranteed at least this CPU
        # Production consideration: Adjust based on actual usage
        
        memory: "2Gi"
        # memory: 2Gi - Memory request
        # Purpose: Minimum memory allocation (2 gigabytes)
        # Impact: Prometheus is guaranteed at least this memory
        # Production consideration: Adjust based on actual usage
      
      limits:
        # limits: Maximum resource usage
        # Purpose: Specifies maximum resources Prometheus can use
        # Impact: Prometheus cannot exceed these limits
        # Production consideration: Prevents resource exhaustion
        
        cpu: "2000m"
        # cpu: 2000m - CPU limit
        # Purpose: Maximum CPU allocation (2 cores)
        # Impact: Prometheus cannot use more than this CPU
        # Production consideration: Adjust based on actual usage
        
        memory: "8Gi"
        # memory: 8Gi - Memory limit
        # Purpose: Maximum memory allocation (8 gigabytes)
        # Impact: Prometheus cannot use more than this memory
        # Production consideration: Adjust based on actual usage
    
    persistence:
      # persistence: Prometheus persistence configuration
      # Purpose: Configures data persistence for Prometheus
      # Impact: Determines how Prometheus data is stored
      # Production consideration: Use appropriate storage classes
      
      enabled: true
      # enabled: true - Enable persistence
      # Purpose: Controls whether to use persistent storage
      # Impact: Prometheus data is persisted when true
      # Production consideration: Always true in production
      
      size: "100Gi"
      # size: 100Gi - Storage size
      # Purpose: Size of the persistent volume
      # Impact: Prometheus has this much storage available
      # Production consideration: Adjust based on actual usage
      
      storageClass: "fast-ssd"
      # storageClass: fast-ssd - Storage class
      # Purpose: Kubernetes storage class to use
      # Impact: Determines storage backend and performance
      # Production consideration: Use appropriate storage classes for production
    
    # Retention configuration
    retention:
      # retention: Data retention configuration
      # Purpose: Configures how long to keep metrics data
      # Impact: Determines storage requirements and data availability
      # Production consideration: Adjust based on compliance requirements
      
      time: "30d"
      # time: 30d - Retention time
      # Purpose: How long to keep metrics data
      # Impact: Metrics data is kept for 30 days
      # Production consideration: Adjust based on compliance requirements
      
      size: "50GB"
      # size: 50GB - Retention size
      # Purpose: Maximum size of metrics data
      # Impact: Metrics data is limited to 50GB
      # Production consideration: Adjust based on storage capacity
  
  # Grafana configuration
  grafana:
    enabled: true
    # enabled: true - Enable Grafana
    # Purpose: Controls whether to deploy Grafana
    # Impact: Grafana is deployed when true
    # Production consideration: Always true in production
    
    image:
      repository: "grafana/grafana"
      # repository: grafana/grafana - Image repository name
      # Purpose: Name of the Grafana image repository
      # Impact: Grafana image is pulled from this repository
      # Production consideration: Use consistent naming across environments
      
      tag: "10.1.0"
      # tag: 10.1.0 - Image tag
      # Purpose: Specific version of the Grafana image
      # Impact: Grafana uses this specific image version
      # Production consideration: Use specific version tags in production
      
      pullPolicy: "IfNotPresent"
      # pullPolicy: IfNotPresent - Image pull policy
      # Purpose: Controls when to pull the image
      # Impact: Image is only pulled if not present locally
      # Production consideration: Use IfNotPresent for stability
    
    replicas: 1
    # replicas: 1 - Number of Grafana replicas
    # Purpose: Controls Grafana scaling
    # Impact: Single replica for data consistency
    # Production consideration: Use single replica for data consistency
    
    resources:
      # resources: Resource requirements and limits
      # Purpose: Specifies CPU and memory requirements
      # Impact: Kubernetes schedules pods based on these requirements
      # Production consideration: Adjust based on actual usage patterns
      
      requests:
        # requests: Minimum resource requirements
        # Purpose: Specifies minimum resources needed
        # Impact: Kubernetes ensures these resources are available
        # Production consideration: Should be based on actual usage
        
        cpu: "200m"
        # cpu: 200m - CPU request
        # Purpose: Minimum CPU allocation (0.2 cores)
        # Impact: Grafana is guaranteed at least this CPU
        # Production consideration: Adjust based on actual usage
        
        memory: "256Mi"
        # memory: 256Mi - Memory request
        # Purpose: Minimum memory allocation (256 megabytes)
        # Impact: Grafana is guaranteed at least this memory
        # Production consideration: Adjust based on actual usage
      
      limits:
        # limits: Maximum resource usage
        # Purpose: Specifies maximum resources Grafana can use
        # Impact: Grafana cannot exceed these limits
        # Production consideration: Prevents resource exhaustion
        
        cpu: "1000m"
        # cpu: 1000m - CPU limit
        # Purpose: Maximum CPU allocation (1 core)
        # Impact: Grafana cannot use more than this CPU
        # Production consideration: Adjust based on actual usage
        
        memory: "1Gi"
        # memory: 1Gi - Memory limit
        # Purpose: Maximum memory allocation (1 gigabyte)
        # Impact: Grafana cannot use more than this memory
        # Production consideration: Adjust based on actual usage
    
    persistence:
      # persistence: Grafana persistence configuration
      # Purpose: Configures data persistence for Grafana
      # Impact: Determines how Grafana data is stored
      # Production consideration: Use appropriate storage classes
      
      enabled: true
      # enabled: true - Enable persistence
      # Purpose: Controls whether to use persistent storage
      # Impact: Grafana data is persisted when true
      # Production consideration: Always true in production
      
      size: "10Gi"
      # size: 10Gi - Storage size
      # Purpose: Size of the persistent volume
      # Impact: Grafana has this much storage available
      # Production consideration: Adjust based on actual usage
      
      storageClass: "fast-ssd"
      # storageClass: fast-ssd - Storage class
      # Purpose: Kubernetes storage class to use
      # Impact: Determines storage backend and performance
      # Production consideration: Use appropriate storage classes for production
    
    admin:
      # admin: Grafana admin configuration
      # Purpose: Configures admin user for Grafana
      # Impact: Determines admin access to Grafana
      # Production consideration: Use strong passwords in production
      
      user: "admin"
      # user: admin - Admin username
      # Purpose: Username for Grafana admin
      # Impact: Admin logs in with this username
      # Production consideration: Use different usernames for different environments
      
      password: "secure_grafana_password"
      # password: secure_grafana_password - Admin password
      # Purpose: Password for Grafana admin
      # Impact: Admin logs in with this password
      # Production consideration: Use strong passwords in production

# =============================================================================
# SECURITY CONFIGURATION
# =============================================================================
security:
  # Security configuration
  enabled: true
  # enabled: true - Enable security features
  # Purpose: Controls whether to enable security features
  # Impact: Security features are enabled when true
  # Production consideration: Always true in production
  
  # Network policies
  networkPolicies:
    enabled: true
    # enabled: true - Enable network policies
    # Purpose: Controls whether to create network policies
    # Impact: Network policies are created when true
    # Production consideration: Always true in production
  
  # Pod security policies
  podSecurityPolicies:
    enabled: true
    # enabled: true - Enable pod security policies
    # Purpose: Controls whether to create pod security policies
    # Impact: Pod security policies are created when true
    # Production consideration: Always true in production
  
  # Resource quotas
  resourceQuotas:
    enabled: true
    # enabled: true - Enable resource quotas
    # Purpose: Controls whether to create resource quotas
    # Impact: Resource quotas are created when true
    # Production consideration: Always true in production
  
  # Limit ranges
  limitRanges:
    enabled: true
    # enabled: true - Enable limit ranges
    # Purpose: Controls whether to create limit ranges
    # Impact: Limit ranges are created when true
    # Production consideration: Always true in production

# =============================================================================
# INGRESS CONFIGURATION
# =============================================================================
ingress:
  # Ingress configuration
  enabled: true
  # enabled: true - Enable ingress in production
  # Purpose: Controls whether to create ingress resources
  # Impact: Ingress resources are created when true
  # Production consideration: Enable in production for external access
  
  className: "nginx"
  # className: nginx - Ingress class name
  # Purpose: Specifies which ingress controller to use
  # Impact: Routes traffic through nginx ingress controller
  # Production consideration: Use appropriate ingress controller
  
  annotations:
    # annotations: Ingress annotations
    # Purpose: Additional configuration for ingress
    # Impact: Configures ingress behavior
    # Production consideration: Use appropriate annotations for production
    nginx.ingress.kubernetes.io/rewrite-target: "/"
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
  
  hosts:
    # hosts: Ingress hosts
    # Purpose: Hostnames for ingress
    # Impact: Determines which hostnames are handled
    # Production consideration: Use appropriate hostnames for production
    - host: "ecommerce.company.com"
      paths:
        - path: "/"
          pathType: "Prefix"
          service:
            name: "ecommerce-frontend-service"
            port: 3000
        - path: "/api"
          pathType: "Prefix"
          service:
            name: "ecommerce-backend-service"
            port: 8000
    - host: "monitoring.company.com"
      paths:
        - path: "/"
          pathType: "Prefix"
          service:
            name: "grafana-service"
            port: 3000
        - path: "/prometheus"
          pathType: "Prefix"
          service:
            name: "prometheus-service"
            port: 9090
  
  tls:
    # tls: TLS configuration
    # Purpose: Configures SSL/TLS termination
    # Impact: Enables encrypted communication
    # Production consideration: Use proper certificates in production
    - secretName: "ecommerce-tls"
      hosts:
        - "ecommerce.company.com"
    - secretName: "monitoring-tls"
      hosts:
        - "monitoring.company.com"
