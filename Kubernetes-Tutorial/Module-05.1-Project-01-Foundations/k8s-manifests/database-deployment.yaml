# =============================================================================
# DATABASE DEPLOYMENT MANIFEST
# =============================================================================
# This manifest defines the deployment configuration for the e-commerce database
# application. It creates a PostgreSQL database that stores application data
# and provides persistent storage for the e-commerce application.
# =============================================================================

apiVersion: apps/v1
kind: Deployment
metadata:
  # =============================================================================
  # METADATA SECTION
  # =============================================================================
  # The metadata section provides identifying information about the deployment
  # resource, including its name, namespace, and labels for organization and
  # selection purposes.
  # =============================================================================
  
  name: ecommerce-database
  # Purpose: Unique identifier for the database deployment within the namespace
  # Why needed: Kubernetes uses this name to identify and manage the deployment
  # Impact: Required for kubectl operations and service discovery
  
  namespace: ecommerce
  # Purpose: Specifies which namespace this deployment belongs to
  # Why needed: Provides logical separation and resource isolation
  # Impact: Ensures database runs in the same namespace as frontend and backend
  
  labels:
    # =============================================================================
    # LABELS SECTION
    # =============================================================================
    # Labels provide key-value pairs for identifying and selecting resources.
    # They enable efficient resource management and service discovery.
    # =============================================================================
    
    app: ecommerce-database
    # Purpose: Identifies this as the database component of the e-commerce application
    # Why needed: Enables service discovery and resource selection
    # Impact: Allows services to target this deployment specifically
    
    tier: database
    # Purpose: Categorizes this as a database tier component
    # Why needed: Enables tier-based resource management and monitoring
    # Impact: Allows filtering and grouping of database resources
    
    version: v1.0.0
    # Purpose: Tracks the version of the database application
    # Why needed: Enables version management and rollback capabilities
    # Impact: Supports blue-green deployments and version tracking
    
    component: database
    # Purpose: Identifies this as a database component
    # Why needed: Enables component-based resource organization
    # Impact: Allows filtering by component type for monitoring and management

spec:
  # =============================================================================
  # SPECIFICATION SECTION
  # =============================================================================
  # The spec section defines the desired state of the deployment, including
  # replica count, selector, template, and container specifications.
  # =============================================================================
  
  replicas: 1
  # Purpose: Specifies the number of database pod replicas to maintain
  # Why needed: Database typically runs as single instance for data consistency
  # Impact: Ensures only one database instance is running at a time
  # Kubernetes concept: ReplicaSet controller maintains the specified number of pods
  # Note: Single replica for database to avoid data consistency issues
  
  selector:
    # =============================================================================
    # SELECTOR SECTION
    # =============================================================================
    # The selector defines how the deployment identifies which pods it manages.
    # It must match the labels in the pod template.
    # =============================================================================
    
    matchLabels:
      app: ecommerce-database
      # Purpose: Matches pods with this specific label
      # Why needed: Enables the deployment to manage the correct pods
      # Impact: Ensures only database pods are managed by this deployment
      
      tier: database
      # Purpose: Ensures only database tier pods are selected
      # Why needed: Provides additional specificity for pod selection
      # Impact: Prevents accidental management of other tier pods

  template:
    # =============================================================================
    # POD TEMPLATE SECTION
    # =============================================================================
    # The template defines the pod specification that will be used to create
    # new pods when scaling or replacing existing ones.
    # =============================================================================
    
    metadata:
      # =============================================================================
      # POD METADATA SECTION
      # =============================================================================
      # Pod metadata includes labels and annotations that identify and describe
      # the pod instances created from this template.
      # =============================================================================
      
      labels:
        app: ecommerce-database
        # Purpose: Identifies individual pods as database components
        # Why needed: Enables service discovery and pod selection
        # Impact: Allows services to route traffic to these pods
        
        tier: database
        # Purpose: Categorizes pods as database tier
        # Why needed: Enables tier-based resource management
        # Impact: Allows filtering and monitoring by tier
        
        version: v1.0.0
        # Purpose: Tracks the version of pods
        # Why needed: Enables version management and rollback
        # Impact: Supports deployment strategies and version tracking
        
        component: database
        # Purpose: Identifies pods as database components
        # Why needed: Enables component-based organization
        # Impact: Allows filtering and management by component type

    spec:
      # =============================================================================
      # POD SPECIFICATION SECTION
      # =============================================================================
      # The pod spec defines the containers, volumes, and other settings
      # that will be applied to each pod created from this template.
      # =============================================================================
      
      containers:
      # =============================================================================
      # CONTAINERS SECTION
      # =============================================================================
      # The containers section defines the application containers that will
      # run within each pod. In this case, we have a single database container.
      # =============================================================================
      
      - name: database
        # Purpose: Unique name for the database container within the pod
        # Why needed: Enables container identification and management
        # Impact: Required for kubectl operations and container-specific commands
        
        image: postgres:15-alpine
        # Purpose: Specifies the Docker image to use for the database container
        # Why needed: Defines the database software and runtime environment
        # Impact: Determines the database version and capabilities
        # Image details: PostgreSQL 15 with Alpine Linux for smaller image size
        
        ports:
        # =============================================================================
        # PORTS SECTION
        # =============================================================================
        # The ports section defines the network ports that the container
        # will listen on and expose to other containers and services.
        # =============================================================================
        
        - containerPort: 5432
          # Purpose: Specifies the port the database container listens on
          # Why needed: Enables network communication with the database
          # Impact: Allows traffic to reach the PostgreSQL database
          # Protocol: PostgreSQL default port 5432
          
          name: postgres
          # Purpose: Names the port for easy reference
          # Why needed: Enables port identification in services and probes
          # Impact: Allows services to reference this port by name
          
          protocol: TCP
          # Purpose: Specifies the network protocol for this port
          # Why needed: Defines the communication protocol
          # Impact: Ensures proper network configuration

        env:
        # =============================================================================
        # ENVIRONMENT VARIABLES SECTION
        # =============================================================================
        # The env section defines environment variables that will be available
        # to the container at runtime, including database configuration.
        # =============================================================================
        
        - name: POSTGRES_DB
          # Purpose: Defines the name of the database to create
          # Why needed: PostgreSQL requires a database name for initialization
          # Impact: Creates the ecommerce database on container startup
          # Value: "ecommerce" matches the application namespace
          
          value: "ecommerce"
          # Purpose: Specifies the database name
          # Why needed: Provides the exact database name for the application
          # Impact: Enables backend to connect to the correct database
        
        - name: POSTGRES_USER
          # Purpose: Defines the database user for application connections
          # Why needed: PostgreSQL requires authentication for connections
          # Impact: Creates a user account for the backend application
          # Value: "ecommerce_user" for application-specific access
          
          value: "ecommerce_user"
          # Purpose: Specifies the database username
          # Why needed: Provides the username for backend authentication
          # Impact: Enables secure database access for the backend
        
        - name: POSTGRES_PASSWORD
          # Purpose: Defines the database password for authentication
          # Why needed: PostgreSQL requires password for user authentication
          # Impact: Provides secure access to the database
          # Value: "ecommerce_password" for development (should use secrets in production)
          
          value: "ecommerce_password"
          # Purpose: Specifies the database password
          # Why needed: Provides the password for backend authentication
          # Impact: Enables secure database access for the backend
          # Security: In production, this should be stored in a Kubernetes secret
        
        - name: PGDATA
          # Purpose: Defines the data directory for PostgreSQL
          # Why needed: PostgreSQL needs to know where to store database files
          # Impact: Ensures data is stored in the mounted volume
          # Value: "/var/lib/postgresql/data" for persistent storage
          
          value: "/var/lib/postgresql/data"
          # Purpose: Specifies the PostgreSQL data directory
          # Why needed: Ensures data is stored in the persistent volume
          # Impact: Enables data persistence across pod restarts

        resources:
        # =============================================================================
        # RESOURCES SECTION
        # =============================================================================
        # The resources section defines CPU and memory limits and requests
        # for the container, ensuring proper resource allocation and management.
        # =============================================================================
        
          requests:
          # =============================================================================
          # RESOURCE REQUESTS SECTION
          # =============================================================================
          # Resource requests specify the minimum resources the container needs
          # to run. Kubernetes uses these for scheduling decisions.
          # =============================================================================
          
            memory: "512Mi"
            # Purpose: Specifies minimum memory required for the database container
            # Why needed: Ensures sufficient memory for PostgreSQL operations
            # Impact: Prevents scheduling on nodes with insufficient memory
            # Unit: MiB (Mebibytes) - binary unit of memory measurement
            
            cpu: "200m"
            # Purpose: Specifies minimum CPU required for the database container
            # Why needed: Ensures sufficient CPU for database operations
            # Impact: Prevents scheduling on nodes with insufficient CPU
            # Unit: "m" represents millicores (1/1000 of a CPU core)
          
          limits:
          # =============================================================================
          # RESOURCE LIMITS SECTION
          # =============================================================================
          # Resource limits specify the maximum resources the container can use.
          # These prevent resource exhaustion and ensure fair resource sharing.
          # =============================================================================
          
            memory: "1Gi"
            # Purpose: Specifies maximum memory the database container can use
            # Why needed: Prevents memory exhaustion and ensures fair resource sharing
            # Impact: Container will be killed if it exceeds this limit
            # Unit: GiB (Gibibytes) - binary unit of memory measurement
            
            cpu: "1000m"
            # Purpose: Specifies maximum CPU the database container can use
            # Why needed: Prevents CPU exhaustion and ensures fair resource sharing
            # Impact: Container will be throttled if it exceeds this limit
            # Unit: "m" represents millicores (1/1000 of a CPU core)

        livenessProbe:
        # =============================================================================
        # LIVENESS PROBE SECTION
        # =============================================================================
        # The liveness probe determines if the container is running properly.
        # If the probe fails, Kubernetes will restart the container.
        # =============================================================================
        
          exec:
          # =============================================================================
          # EXEC PROBE SECTION
          # =============================================================================
          # Exec probe executes a command inside the container to check health.
          # This is ideal for database applications that don't serve HTTP.
          # =============================================================================
          
            command:
            # =============================================================================
            # COMMAND SECTION
            # =============================================================================
            # The command section defines the command to execute for health checking.
            # For PostgreSQL, we use pg_isready to check database availability.
            # =============================================================================
            
            - pg_isready
            # Purpose: PostgreSQL utility to check if database is ready to accept connections
            # Why needed: Provides reliable health checking for PostgreSQL
            # Impact: Kubernetes will restart container if database is not ready
            # Command: pg_isready checks database server status
            
            - -U
            # Purpose: Specifies the user for the health check
            # Why needed: pg_isready requires a user to check database availability
            # Impact: Ensures health check uses the correct database user
            # Flag: -U flag specifies the username
            
            - ecommerce_user
            # Purpose: Specifies the database user for the health check
            # Why needed: Uses the same user as the application for consistency
            # Impact: Ensures health check reflects actual application access
            # User: ecommerce_user matches the application database user
        
          initialDelaySeconds: 30
          # Purpose: Specifies delay before first liveness probe
          # Why needed: Allows container time to start up and initialize database
          # Impact: Prevents premature container restarts during startup
          # Time: 30 seconds delay for PostgreSQL to initialize
          
          periodSeconds: 10
          # Purpose: Specifies interval between liveness probe checks
          # Why needed: Provides regular health monitoring
          # Impact: Balances monitoring frequency with resource usage
          # Time: Check every 10 seconds for responsive health monitoring
          
          timeoutSeconds: 5
          # Purpose: Specifies timeout for each liveness probe
          # Why needed: Prevents hanging probes from blocking container management
          # Impact: Ensures timely detection of unhealthy containers
          # Time: 5 second timeout for pg_isready command
          
          failureThreshold: 3
          # Purpose: Specifies number of consecutive failures before restart
          # Why needed: Prevents restarts due to temporary database issues
          # Impact: Provides resilience against transient failures
          # Count: 3 consecutive failures trigger container restart

        readinessProbe:
        # =============================================================================
        # READINESS PROBE SECTION
        # =============================================================================
        # The readiness probe determines if the container is ready to receive traffic.
        # If the probe fails, the container is removed from service endpoints.
        # =============================================================================
        
          exec:
          # =============================================================================
          # EXEC PROBE SECTION
          # =============================================================================
          # Exec probe executes a command inside the container to check readiness.
          # This ensures the container is fully initialized before receiving traffic.
          # =============================================================================
          
            command:
            # =============================================================================
            # COMMAND SECTION
            # =============================================================================
            # The command section defines the command to execute for readiness checking.
            # For PostgreSQL, we use pg_isready to check database readiness.
            # =============================================================================
            
            - pg_isready
            # Purpose: PostgreSQL utility to check if database is ready to accept connections
            # Why needed: Provides reliable readiness checking for PostgreSQL
            # Impact: Container won't receive traffic until database is ready
            # Command: pg_isready checks database server readiness
            
            - -U
            # Purpose: Specifies the user for the readiness check
            # Why needed: pg_isready requires a user to check database readiness
            # Impact: Ensures readiness check uses the correct database user
            # Flag: -U flag specifies the username
            
            - ecommerce_user
            # Purpose: Specifies the database user for the readiness check
            # Why needed: Uses the same user as the application for consistency
            # Impact: Ensures readiness check reflects actual application access
            # User: ecommerce_user matches the application database user
        
          initialDelaySeconds: 5
          # Purpose: Specifies delay before first readiness probe
          # Why needed: Allows container time to start up and initialize
          # Impact: Prevents premature traffic routing during startup
          # Time: 5 seconds delay for PostgreSQL to initialize
          
          periodSeconds: 5
          # Purpose: Specifies interval between readiness probe checks
          # Why needed: Provides regular readiness monitoring
          # Impact: Balances monitoring frequency with resource usage
          # Time: Check every 5 seconds for responsive readiness monitoring
          
          timeoutSeconds: 3
          # Purpose: Specifies timeout for each readiness probe
          # Why needed: Prevents hanging probes from blocking traffic routing
          # Impact: Ensures timely detection of unready containers
          # Time: 3 second timeout for pg_isready command
          
          successThreshold: 1
          # Purpose: Specifies number of consecutive successes to mark as ready
          # Why needed: Ensures container is consistently ready before traffic routing
          # Impact: Provides confidence in container readiness
          # Count: 1 success marks container as ready
          
          failureThreshold: 3
          # Purpose: Specifies number of consecutive failures before marking unready
          # Why needed: Prevents traffic routing to unhealthy containers
          # Impact: Ensures only healthy containers receive traffic
          # Count: 3 consecutive failures mark container as unready

        volumeMounts:
        # =============================================================================
        # VOLUME MOUNTS SECTION
        # =============================================================================
        # The volumeMounts section defines where volumes are mounted in the container.
        # This enables persistent storage for the database data.
        # =============================================================================
        
        - name: postgres-storage
          # Purpose: References the volume to mount in the container
          # Why needed: Enables persistent storage for database data
          # Impact: Ensures data persists across pod restarts
          # Volume: postgres-storage volume for database data
          
          mountPath: /var/lib/postgresql/data
          # Purpose: Specifies the path where the volume is mounted
          # Why needed: PostgreSQL expects data to be stored in this directory
          # Impact: Database data is stored in the persistent volume
          # Path: Standard PostgreSQL data directory

        imagePullPolicy: IfNotPresent
        # Purpose: Specifies when to pull the container image
        # Why needed: Controls image update behavior and resource usage
        # Impact: Balances image freshness with resource efficiency
        # Policy: Only pull if image not present locally (faster startup)

      volumes:
      # =============================================================================
      # VOLUMES SECTION
      # =============================================================================
      # The volumes section defines the storage volumes available to the pod.
      # This enables persistent storage for the database data.
      # =============================================================================
      
      - name: postgres-storage
        # Purpose: Defines a volume for PostgreSQL data storage
        # Why needed: Enables persistent storage for database data
        # Impact: Ensures data persists across pod restarts
        # Volume: postgres-storage for database data
        
        emptyDir: {}
        # Purpose: Creates an empty directory volume for data storage
        # Why needed: Provides temporary storage for database data
        # Impact: Data is lost when pod is deleted (not persistent)
        # Note: In production, use PersistentVolume for true persistence

      restartPolicy: Always
      # Purpose: Specifies restart behavior for the pod
      # Why needed: Ensures high availability and fault tolerance
      # Impact: Pod will be restarted if it fails or is terminated
      # Policy: Always restart regardless of exit reason

      terminationGracePeriodSeconds: 30
      # Purpose: Specifies grace period for pod termination
      # Why needed: Allows graceful shutdown of the database
      # Impact: Prevents data loss and ensures clean shutdown
      # Time: 30 seconds for PostgreSQL to save data and close connections

      dnsPolicy: ClusterFirst
      # Purpose: Specifies DNS resolution policy for the pod
      # Why needed: Ensures proper service discovery within the cluster
      # Impact: Enables database to resolve backend service names
      # Policy: Use cluster DNS first, then fall back to host DNS

      securityContext:
      # =============================================================================
      # SECURITY CONTEXT SECTION
      # =============================================================================
      # The security context defines security settings for the pod and containers.
      # This ensures secure operation and compliance with security policies.
      # =============================================================================
      
        runAsNonRoot: true
        # Purpose: Ensures the container runs as a non-root user
        # Why needed: Improves security by reducing privilege escalation risks
        # Impact: Prevents potential security vulnerabilities from root access
        # Security: Reduces attack surface and follows security best practices
        
        runAsUser: 999
        # Purpose: Specifies the user ID for the container process
        # Why needed: Ensures consistent and secure user identity
        # Impact: Provides predictable security context for the database
        # User: UID 999 is the standard PostgreSQL user ID
        
        fsGroup: 999
        # Purpose: Specifies the group ID for file system access
        # Why needed: Ensures proper file permissions and access control
        # Impact: Provides secure file system access for the database
        # Group: GID 999 matches the PostgreSQL user ID for consistent permissions

# =============================================================================
# END OF DATABASE DEPLOYMENT MANIFEST
# =============================================================================
# This manifest creates a secure and monitored database deployment for the
# e-commerce application that includes:
# - Single replica for data consistency
# - Resource limits and requests for proper resource management
# - Health checks for reliability monitoring
# - Security context for secure operation
# - Environment variables for database configuration
# - Volume mounts for data persistence
# =============================================================================
