# Deployment Stage Configuration
# Handles deployment to staging and production environments

.deploy_template: &deploy_template
  image: bitnami/kubectl:latest
  before_script:
    - echo "üöÄ Setting up deployment environment..."
    - echo $KUBE_CONFIG | base64 -d > ~/.kube/config
    - kubectl version --client
    - helm version --client
  after_script:
    - rm -f ~/.kube/config

# Deploy to Staging Environment
deploy-staging:
  <<: *deploy_template
  stage: deploy-staging
  environment:
    name: staging
    url: https://staging.ecommerce.example.com
    deployment_tier: staging
  script:
    - echo "üöÄ Deploying to staging environment..."
    - |
      # Create namespace if it doesn't exist
      kubectl create namespace ecommerce-staging --dry-run=client -o yaml | kubectl apply -f -
      
      # Update image tags in Kubernetes manifests
      sed -i "s|IMAGE_TAG|$CI_COMMIT_SHA|g" k8s/staging/deployment.yml
      
      # Apply Kubernetes manifests
      kubectl apply -f k8s/staging/ -n ecommerce-staging
      
      # Wait for deployment to complete
      kubectl rollout status deployment/backend -n ecommerce-staging --timeout=300s
      kubectl rollout status deployment/frontend -n ecommerce-staging --timeout=300s
      
      # Run database migrations
      kubectl exec -n ecommerce-staging deployment/backend -- python manage.py migrate
      
      # Verify deployment
      kubectl get pods -n ecommerce-staging
      kubectl get services -n ecommerce-staging
    - echo "‚úÖ Staging deployment completed successfully"
  artifacts:
    reports:
      dotenv: deploy-staging.env
    expire_in: 1 week
  rules:
    - if: $CI_COMMIT_BRANCH == "develop"
    - if: $CI_COMMIT_BRANCH == "main"
      when: manual
  dependencies:
    - build-backend
    - build-frontend

# Deploy to Production Environment
deploy-production:
  <<: *deploy_template
  stage: deploy-production
  environment:
    name: production
    url: https://ecommerce.example.com
    deployment_tier: production
  script:
    - echo "üöÄ Deploying to production environment..."
    - |
      # Backup current deployment
      kubectl create backup production-backup-$(date +%Y%m%d-%H%M%S) -n ecommerce-prod || true
      
      # Blue-Green Deployment Strategy
      CURRENT_COLOR=$(kubectl get service frontend -n ecommerce-prod -o jsonpath='{.spec.selector.color}' || echo "blue")
      NEW_COLOR=$([ "$CURRENT_COLOR" = "blue" ] && echo "green" || echo "blue")
      
      echo "Current color: $CURRENT_COLOR, Deploying to: $NEW_COLOR"
      
      # Update manifests with new color and image tags
      sed -i "s|IMAGE_TAG|$CI_COMMIT_SHA|g" k8s/production/deployment.yml
      sed -i "s|COLOR_PLACEHOLDER|$NEW_COLOR|g" k8s/production/deployment.yml
      
      # Deploy new version
      kubectl apply -f k8s/production/ -n ecommerce-prod
      
      # Wait for new deployment to be ready
      kubectl rollout status deployment/backend-$NEW_COLOR -n ecommerce-prod --timeout=600s
      kubectl rollout status deployment/frontend-$NEW_COLOR -n ecommerce-prod --timeout=600s
      
      # Run health checks
      kubectl exec -n ecommerce-prod deployment/backend-$NEW_COLOR -- curl -f http://localhost:8000/health
      
      # Switch traffic to new deployment
      kubectl patch service backend -n ecommerce-prod -p '{"spec":{"selector":{"color":"'$NEW_COLOR'"}}}'
      kubectl patch service frontend -n ecommerce-prod -p '{"spec":{"selector":{"color":"'$NEW_COLOR'"}}}'
      
      # Wait and verify
      sleep 30
      curl -f https://ecommerce.example.com/health
      
      # Scale down old deployment
      kubectl scale deployment backend-$CURRENT_COLOR --replicas=0 -n ecommerce-prod || true
      kubectl scale deployment frontend-$CURRENT_COLOR --replicas=0 -n ecommerce-prod || true
    - echo "‚úÖ Production deployment completed successfully"
  artifacts:
    reports:
      dotenv: deploy-production.env
    expire_in: 1 month
  rules:
    - if: $CI_COMMIT_TAG
    - if: $CI_COMMIT_BRANCH == "main"
      when: manual
  dependencies:
    - build-backend
    - build-frontend
    - deploy-staging

# Canary Deployment (Alternative Strategy)
deploy-canary:
  <<: *deploy_template
  stage: deploy-production
  environment:
    name: production-canary
    url: https://canary.ecommerce.example.com
    deployment_tier: production
  script:
    - echo "üê§ Starting canary deployment..."
    - |
      # Deploy canary version (10% traffic)
      sed -i "s|IMAGE_TAG|$CI_COMMIT_SHA|g" k8s/canary/deployment.yml
      kubectl apply -f k8s/canary/ -n ecommerce-prod
      
      # Wait for canary to be ready
      kubectl rollout status deployment/backend-canary -n ecommerce-prod --timeout=300s
      kubectl rollout status deployment/frontend-canary -n ecommerce-prod --timeout=300s
      
      # Configure traffic splitting (10% to canary)
      kubectl apply -f k8s/canary/istio-virtual-service.yml -n ecommerce-prod
      
      echo "Canary deployment active with 10% traffic"
      echo "Monitor metrics and run: 'promote-canary' job to complete deployment"
    - echo "‚úÖ Canary deployment started"
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: manual
  dependencies:
    - build-backend
    - build-frontend

# Promote Canary to Full Production
promote-canary:
  <<: *deploy_template
  stage: deploy-production
  environment:
    name: production
    url: https://ecommerce.example.com
    deployment_tier: production
  script:
    - echo "üöÄ Promoting canary to full production..."
    - |
      # Gradually increase canary traffic
      for percentage in 25 50 75 100; do
        echo "Increasing canary traffic to ${percentage}%"
        sed "s|CANARY_PERCENTAGE|$percentage|g" k8s/canary/istio-virtual-service-template.yml | kubectl apply -f - -n ecommerce-prod
        sleep 120  # Wait 2 minutes between increases
        
        # Check error rates and metrics
        ERROR_RATE=$(kubectl exec -n monitoring deployment/prometheus -- promtool query instant 'rate(http_requests_total{status=~"5.."}[5m])' | tail -1)
        if (( $(echo "$ERROR_RATE > 0.01" | bc -l) )); then
          echo "High error rate detected: $ERROR_RATE. Rolling back..."
          kubectl apply -f k8s/production/istio-virtual-service.yml -n ecommerce-prod
          exit 1
        fi
      done
      
      # Replace main deployment with canary
      kubectl patch deployment backend -n ecommerce-prod --patch "$(kubectl get deployment backend-canary -n ecommerce-prod -o json | jq '.spec.template')"
      kubectl patch deployment frontend -n ecommerce-prod --patch "$(kubectl get deployment frontend-canary -n ecommerce-prod -o json | jq '.spec.template')"
      
      # Clean up canary resources
      kubectl delete -f k8s/canary/ -n ecommerce-prod
    - echo "‚úÖ Canary promotion completed"
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: manual
  dependencies:
    - deploy-canary

# Rollback Deployment
rollback-production:
  <<: *deploy_template
  stage: deploy-production
  environment:
    name: production
    url: https://ecommerce.example.com
    deployment_tier: production
  script:
    - echo "üîÑ Rolling back production deployment..."
    - |
      # Get previous revision
      PREVIOUS_REVISION=$(kubectl rollout history deployment/backend -n ecommerce-prod | tail -2 | head -1 | awk '{print $1}')
      
      # Rollback to previous version
      kubectl rollout undo deployment/backend -n ecommerce-prod --to-revision=$PREVIOUS_REVISION
      kubectl rollout undo deployment/frontend -n ecommerce-prod --to-revision=$PREVIOUS_REVISION
      
      # Wait for rollback to complete
      kubectl rollout status deployment/backend -n ecommerce-prod --timeout=300s
      kubectl rollout status deployment/frontend -n ecommerce-prod --timeout=300s
      
      # Verify rollback
      kubectl get pods -n ecommerce-prod
      curl -f https://ecommerce.example.com/health
    - echo "‚úÖ Rollback completed successfully"
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: manual
  allow_failure: false

# Infrastructure Deployment with Terraform
deploy-infrastructure:
  stage: deploy-staging
  image: hashicorp/terraform:latest
  before_script:
    - cd terraform/
    - terraform --version
    - terraform init
  script:
    - echo "üèóÔ∏è Deploying infrastructure with Terraform..."
    - |
      # Plan infrastructure changes
      terraform plan -out=tfplan -var-file="environments/${CI_ENVIRONMENT_NAME}.tfvars"
      
      # Apply changes (auto-approve in CI/CD)
      terraform apply -auto-approve tfplan
      
      # Output important values
      terraform output -json > ../terraform-outputs.json
    - echo "‚úÖ Infrastructure deployment completed"
  artifacts:
    paths:
      - terraform-outputs.json
      - terraform/tfplan
    expire_in: 1 week
  rules:
    - changes:
        - terraform/**/*
    - if: $CI_COMMIT_BRANCH == "main"
      when: manual
  environment:
    name: $CI_ENVIRONMENT_NAME
    action: start

# Database Migration Job
migrate-database:
  stage: deploy-staging
  image: python:3.11-slim
  script:
    - echo "üóÑÔ∏è Running database migrations..."
    - |
      cd backend
      pip install -r requirements.txt
      
      # Run migrations
      python manage.py migrate --check
      python manage.py migrate
      
      # Seed initial data if needed
      if [ "$CI_ENVIRONMENT_NAME" = "staging" ]; then
        python manage.py loaddata fixtures/initial_data.json
      fi
    - echo "‚úÖ Database migrations completed"
  rules:
    - changes:
        - backend/migrations/**/*
        - backend/models/**/*
    - if: $CI_COMMIT_BRANCH == "develop"
    - if: $CI_COMMIT_BRANCH == "main"
      when: manual
  environment:
    name: $CI_ENVIRONMENT_NAME
